//--- 010 Editor v9.02 Binary Template
//
//      File: DMC5_motlist.bt
//   Authors: alphaZomega, Che, Jackal
//   Version: 0.74
//   Purpose: Parse RE Engine motlist files
//  Category: RE Engine
// File Mask: *.motlist.*
//  ID Bytes: [+4] 6D 6C 73 74
//   History: October 14 2021
//------------------------------------------------
LittleEndian();

//Set this to TRUE to make the template skip decompressing all the frame data:
local int SKIP_UNPACK <hidden=true> = FALSE; 
local int SKIPALL <hidden=true> = FALSE; 
local int NOCLIP <hidden=true> = FALSE;

local int64 i <hidden=true> = 0, numOffs <hidden=true> = 0, isEndOfClip <hidden=true> = FALSE,
            j <hidden=true> = 0, pos <hidden=true>, Type <hidden=true>,
            start <hidden=true>, k <hidden=true> = 0, fnData <hidden=true>,
            frame <hidden=true>, pos2 <hidden=true>, pos3 <hidden=true>,
            motCounter <hidden=true> = 0, boneHeadersIdx <hidden=true> = 0, version <hidden=true>;
local char  bytes[8] <hidden=true>;
local byte  bIsMotFile <hidden=true>;
local int runningTotal <hidden=true>;
local int propSize <hidden=true> = 112;
local int keySize <hidden=true> = 40;

/* ----DEFINITIONS---- */
#define TRANSLATION (1)
#define ROTATION (1 << 1)
#define SCALE (1 << 2)

void findEndOfMot() {
    while (FTell()+4 < FileSize()) {
        if (ReadUInt(FTell()) == 544501613) {
            FSkip(-4); break;
        }
        FSkip(1);
    }
}

uint getMotSize(uint offset) {
	local uint posStart = FTell();
	local uint posEnd = offset;
	FSeek(offset);
    while (FTell()+4 < FileSize()) {
        if (ReadUInt(FTell()) == 544501613 || FTell() == HEADER.colOffs || FTell() == FileSize()) {
			if (ReadUInt(FTell()) == 544501613)
            	FSkip(-4); 
			break;
        }
        FSkip(1);
    }
	posEnd = FTell();
	FSeek(posStart);
	return posEnd;
}

int findNextOfInt(int toFind) {
    pos3 = FTell();
    while (FTell()+4 < FileSize()) {
        if (ReadUInt(FTell()) == toFind) {
            FSkip(-4); break;
        }
        FSkip(1);
    }
    local int finalPos = FTell();
    if (FTell()==FileSize()-4) 
        finalPos = FileSize();
    
    FSeek(pos3);
    return finalPos;
}

void skipToNextLine() {
    while (FTell() % 16 != 0) FSkip(1);
}

uint isHighestOffset(uint64 offset) {
    for (j=0; j<HEADER.numOffs; j++) {
        if (HEADER.Pointers[j] > offset)
            return 0;
    }
    return 1;
}

uint isBeforeColOffs(uint64 offset) {
    for (j=0; j<HEADER.numOffs; j++) {
        if (HEADER.Pointers[j] > offset && HEADER.Pointers[j] < HEADER.colOffs)
            return 0;
    }
    return 1;
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        return (ReadUByte(offset+3) != 255 && flt != 0 && (Abs(flt) > 0.000001 && Abs(flt) < 10000000) );
    } return false;
}

//generic string reader
typedef struct(int64 atAddress, int64 addOffset, ubyte isAbsolute, ubyte isUTF8, ubyte isUint32) 
{
    if (!isAbsolute) {
        if (atAddress > -1)
            FSeek(atAddress);
        if (isUint32)
            uint32 strOffset;
        else
            uint64 strOffset;
        FSeek(strOffset + addOffset);
    } else 
        FSeek(atAddress + addOffset);

    if (!exists(strOffset) || strOffset > 0)
        if (isUTF8)
            string String;
        else
            wstring String;
    
    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress)
            FSeek(startof(strOffset) + 8 - isUint32 * 4);
        else 
            FSeek(startof(this)+1);
    }
    
} StringRead <read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { 
        if (exists(st.String)) 
            return st.String;
        local string s;
        if (exists(st.strOffset))
            SPrintf(s, "%i", st.strOffset); 
        return s; 
    }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (exists(st.String))
            st.String = s; 
        else if (exists(st.strOffset))
            st.strOffset = Atoi(s);
    }

typedef struct {
    uchar uuid[16];
} rGUID <read=ReadrGUID>;

    string ReadrGUID (rGUID &g) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            g.uuid[0], g.uuid[1], g.uuid[2], g.uuid[3], g.uuid[4], g.uuid[5], g.uuid[6], g.uuid[7],
            g.uuid[8], g.uuid[9], g.uuid[10], g.uuid[11], g.uuid[12], g.uuid[13], g.uuid[14], g.uuid[15]
        );
        return s;
    }

typedef ushort trckFlg_t<read=ReadTrckFlg, write=WriteTrckFlg>;
    string ReadTrckFlg(trckFlg_t f){
        string s;
        SPrintf(s, "%c %c %c", 
                 84 * (f & TRANSLATION),
                 82 * ( (f & ROTATION) >> 1 ),
                 83 * ( (f & SCALE) >> 2 )
                );
        return s;
    }

typedef struct KEY {
    float frame;
    float rate;
    enum {
        InterpolationType_Unknown = 0x0,
        InterpolationType_Discrete = 0x1,
        InterpolationType_Linear = 0x2,
        InterpolationType_Event = 0x3,
        InterpolationType_Slerp = 0x4,
        InterpolationType_Hermite = 0x5,
        InterpolationType_AutoHermite = 0x6,
        InterpolationType_Bezier = 0x7,
        InterpolationType_AutoBezier = 0x8,
        InterpolationType_OffsetFrame = 0x9,
        InterpolationType_OffsetSec = 0xA,
        InterpolationType_PassEvent = 0xB,
        InterpolationType_Bezier3D = 0xC,
        InterpolationType_Range = 0xD,
        InterpolationType_DiscreteToEnd = 0xE,
    } interpolationType : 8;
    uint32 instanceValue : 1;
    uint32 reserved : 23 <hidden=true>;
    uint32 reserved2 <hidden=true>;
    
    if (exists(parentof(this).PropInfo.DataType)) {
        switch (parentof(this).PropInfo.DataType) {

            //PropertyType_Unknown:
            case PropertyType_Bool:
            case PropertyType_S8:
                byte value : 1; break;
            case PropertyType_U8:
                ubyte value : 1; break;
            case PropertyType_S16:
                int16 value; break;
            case PropertyType_U16:
                uint16 value; break;
            case PropertyType_S32:
                int32 value; break;
            case PropertyType_U32:
                uint32 value; break;
            case PropertyType_S64:
                int64 value; break;
            case PropertyType_U64:
                uint64 value; break;
            case PropertyType_F32:
                double value; break;
            case PropertyType_F64:
                double value; break;
            case PropertyType_Str8:
            case PropertyType_Enum:
                uint64 value; 
                FSeek(clipHeader.namesOffsExtra[1] + start + value);
                string String;
                break;
            case PropertyType_Guid:
            case PropertyType_Str16:
            case PropertyType_Asset:
                uint64 value; 
                FSeek(clipHeader.unicodeNamesOffs + start + value*2);
                wstring String;
                break;
            default:
                int64 value;
                break;
        }
    } else {
        int64 value;
        FSkip(-8);
        double value;
    }
    //FSeek(startof(value)+16);
    //uint64 interpolationOffset;
    FSeek(startof(this)+keySize);
};

typedef KEY clipKey <name=ReadKeyName, read=ReadClipKey, write=WriteClipKey>;
    
    string ReadKeyName (clipKey &k) { string s; SPrintf(s, "Key@%g ", k.frame); return s; }
    
    string ReadClipKey (clipKey &k) { 
        local string s, t;
        if (exists(k.String)) {
            s += (wstring)k.String;
        } else if (detectedFloat(startof(k.value)) || detectedFloat(startof(k.value)+4) && ReadUInt64(startof(k.value)) != 0)
            SPrintf(s, "%lf", ReadDouble(startof(k.value)));
        else
            SPrintf(s, "%i", ReadInt(startof(k.value)));
        if (exists(k.interpolationHermiteValue)) 
            SPrintf(s, "%s  (%lf)", s, k.interpolationHermiteValue);
        
        return s; 
    }

    void WriteClipKey(clipKey &k, string s) {
        if (exists(parentof(k).PropInfo.DataType) && parentof(k).PropInfo.DataType == PropertyType_F32)
            WriteDouble(startof(k.value), Atof(s));
        else
            WriteInt64(startof(k.value), Atoi(s));
    }

enum <ubyte> PropertyType
{
  PropertyType_Unknown = 0x0,
  PropertyType_Bool = 0x1,
  PropertyType_S8 = 0x2,
  PropertyType_U8 = 0x3,
  PropertyType_S16 = 0x4,
  PropertyType_U16 = 0x5,
  PropertyType_S32 = 0x6,
  PropertyType_U32 = 0x7,
  PropertyType_S64 = 0x8,
  PropertyType_U64 = 0x9,
  PropertyType_F32 = 0xA,
  PropertyType_F64 = 0xB,
  PropertyType_Str8 = 0xC,
  PropertyType_Str16 = 0xD,
  PropertyType_Enum = 0xE,
  PropertyType_Quaternion = 0xF,
  PropertyType_Array = 0x10,
  PropertyType_NativeArray = 0x11,
  PropertyType_Class = 0x12,
  PropertyType_NativeClass = 0x13,
  PropertyType_Struct = 0x14,
  PropertyType_Vec2 = 0x15,
  PropertyType_Vec3 = 0x16,
  PropertyType_Vec4 = 0x17,
  PropertyType_Color = 0x18,
  PropertyType_Range = 0x19,
  PropertyType_Float2 = 0x1A,
  PropertyType_Float3 = 0x1B,
  PropertyType_Float4 = 0x1C,
  PropertyType_RangeI = 0x1D,
  PropertyType_Point = 0x1E,
  PropertyType_Size = 0x1F,
  PropertyType_Asset = 0x20,
  PropertyType_Action = 0x21,
  PropertyType_Guid = 0x22,
  PropertyType_Uint2 = 0x23,
  PropertyType_Uint3 = 0x24,
  PropertyType_Uint4 = 0x25,
  PropertyType_Int2 = 0x26,
  PropertyType_Int3 = 0x27,
  PropertyType_Int4 = 0x28,
  PropertyType_OBB = 0x29,
  PropertyType_Mat4 = 0x2A,
  PropertyType_Rect = 0x2B,
  PropertyType_PathPoint3D = 0x2C,
  PropertyType_Plane = 0x2D,
  PropertyType_Sphere = 0x2E,
  PropertyType_Capsule = 0x2F,
  PropertyType_AABB = 0x30,
  PropertyType_Nullable = 0x31,
  PropertyType_Sfix = 0x32,
  PropertyType_Sfix2 = 0x33,
  PropertyType_Sfix3 = 0x34,
  PropertyType_Sfix4 = 0x35,
  PropertyType_AnimationCurve = 0x36,
  PropertyType_KeyFrame = 0x37,
  PropertyType_GameObjectRef = 0x38,
};

typedef struct {
    struct PROPINFO {
        if (HEADER.version==60) {
            PropertyType DataType;
            FSkip(3);
        }
        if (HEADER.version != 486) 
            uint32 pad <hidden=true>;
        float ValueA <name="Value A (Start)">;
        float ValueB <name="Value B (End)">;
        if (HEADER.version==60) {
            uint32 U32_1;
            uint32 U32_2;
        } else 
            uint64 U64_1;
        
        if (HEADER.version == 486) { //RE8
                uint64 nameOffset;
                uint64 dataOffset;
                uint64 ChildStartIndex;
                ushort ChildMembershipCount;
                short arrayIndex;
                short speedPointNum;
                PropertyType DataType;
                ubyte uknByte;
                uint64 lastKeyOffset;
                uint64 speedPointOffset;
                uint64 clipPropertyOffset;
        } else {
            if (HEADER.version == 60) {
                FSkip(24);
            } else {
                PropertyType DataType;
                ubyte uknCount <hidden=true>;
                FSkip(2);
                if (HEADER.version == 99)
                    uint64 RE3hash;
                else FSkip(8);
            }
            uint64 nameOffset, nameOffset;
            
            if (HEADER.version == 60) {
                uint64 uknRE7;
                FSkip(8); 
            } 
            FSkip(8);
            if (HEADER.version != 60)
                FSkip(16);
            
            uint64 ChildStartIndex, ChildMembershipCount;
            if (HEADER.version == 60) {
                FSkip(8);
                uint64 uknRE7;
            }
        }
        FSeek(clipHeader.namesOffsExtra[1] + start + PropInfo.nameOffset[0]);
        string FunctionName  <hidden=false>;
        if (HEADER.version != 486 && PropInfo.nameOffset[1] > 0) {
            FSeek(clipHeader.unicodeNamesOffs + start + PropInfo.nameOffset[1]*2);
            wstring wFunctionName <hidden=false>;
        }
        FSeek(startof(this)+propSize);
    } PropInfo <read=ReadPROPINFO, name="[PropInfo]">;
    
    switch (PropInfo.DataType) {
        case PropertyType_NativeArray:
        case PropertyType_Nullable:
        case PropertyType_NativeClass:
        case PropertyType_Range:
        case PropertyType_RangeI:
        case PropertyType_Vec4:
        case PropertyType_Vec3:
        case PropertyType_Vec2:
        case PropertyType_Float4:
        case PropertyType_Quaternion:
        case PropertyType_OBB:
        case PropertyType_Mat4:
        case PropertyType_Class:
        case PropertyType_Array:
        case PropertyType_Struct:
        case PropertyType_Color:
        case PropertyType_Float2:
        case PropertyType_Float3:
        case PropertyType_Point:

            FSeek(clipHeader.propertiesOffs + start + (propSize*PropInfo.ChildStartIndex));
            if (PropInfo.ChildMembershipCount)
                struct PROPERTY ChildProp[PropInfo.ChildMembershipCount] <optimize=false>;
            break;
        default:
            FSeek(clipHeader.keysOffs + start + (keySize*PropInfo.ChildStartIndex));
            if (PropInfo.ChildMembershipCount){
                Type = PropInfo.DataType;
                struct clipKey Keys[PropInfo.ChildMembershipCount] <optimize=false>;
            }
            break;
    }
    
    FSeek(startof(this)+propSize);
} PROPERTY <name=ReadPROPERTYNAME, read=ReadPROPERTY, write=WritePROPERTY>;

    string ReadPROPERTY (PROPERTY &input) { 
        string s = "";
        SPrintf(s, "[%i, %i]", input.PropInfo.ValueA, input.PropInfo.ValueB );
        return s; 
    }
    
    string ReadPROPERTYNAME (PROPERTY &input) { 
        local string fnName;
        if (exists(input.PropInfo.FunctionName)) {
            fnName = input.PropInfo.FunctionName;
            if (exists(input.PropInfo.wFunctionName))
                fnName = input.PropInfo.wFunctionName;
            if (exists(input.ChildProp)) {
                local string s;
                SPrintf(s, "*[%ix] %s", input.PropInfo.ChildMembershipCount, fnName );
                return s;
            } else if (exists(input.Keys))
                return  "* " + fnName;
            else 
                return fnName; 
        }
        return ""; 
    }
    
    void WritePROPERTY (PROPERTY &f, string s ) {  SScanf(s, "%g %g", f.PropInfo.ValueA, f.PropInfo.ValueB); }

    string ReadPROPINFO(PROPINFO &p) { return EnumToString(p.DataType); }

typedef struct {
    if (HEADER.version != 486) {
        uint32 nodeCount, propCount;
        float Start_Frame, End_Frame;
        struct rGUID GUIDs[2];
        FSkip(8); 
    } else {
        ushort nodeCount;
        ushort propCount;
        uint nodeType : 8;
        uint padding : 24 <hidden=true>;
    }
    uint64 hash; 
    uint64 nameOffset, nameOffset, firstPropIdx;
    if (HEADER.version == 85) 
        uint64 firstPropIdx;
    pos = FTell();
    if (HEADER.version == 99) {
        FSeek(clipHeader.unicodeNamesOffs + start + nameOffset[0] * 2);
        wstring name;
    } else if (HEADER.version == 486) {
        FSeek(clipHeader.unicodeNamesOffs + start + nameOffset[0] * 2);
        wstring name;
    } else {
        FSeek(clipHeader.namesOffsExtra[1] + start + nameOffset[0]);
        string name;
    }
    FSeek(pos);
} CTRACKS <read=ReadCTRACKS>;
    string ReadCTRACKS (CTRACKS &input) { return input.name; }
    

typedef struct {
    
    if (HEADER.version == 486) {
        propSize = 72;
        keySize = 32;
    } else if (HEADER.version==60) {
        propSize = 120;
    } else if (HEADER.version==99) {
        keySize = 32;
    }

    if (isEndOfClip) {
        uint64 endClipOffs;
        FSeek(endClipOffs);
    }
    
    struct {
        
        FSkip(8);
        uint64 ClipOffset;
        uint64 endClipStructsRelocation;
        FSkip(4);
        uint32 uknIntA;
        uint32 uknIntB;
        FSeek(startof(this)+64); 
        
        uint32 Magic;
        uint32 version; 
        float NumFrames; 
        uint32 numNodes, numProperties, numKeys;
        
        if (HEADER.version != 99 && HEADER.version != 486)
            rGUID Guid;
        
        uint64 clipDataOffs, propertiesOffs;
        uint64 keysOffs;
        uint64 namesOffs;
        
        if (HEADER.version == 85)
            uint64 namesOffs2;
        
        if (HEADER.version == 60) 
            uint64 namesOffsExtra[5];
        else 
            uint64 namesOffsExtra[4];
        
        uint64 unicodeNamesOffs;
        uint64 endClipStructsOffs;
        uint64 endClipStructsOffs;
        FSeek(endClipStructsOffs[1] + start + 8);
        uint64 endClipStructsRelocation <hidden=false>;
        FSeek(startof(endClipStructsOffs[1])+8);
        
    } clipHeader <name="Header">;

    FSeek(clipHeader.clipDataOffs + start);
    if (clipHeader.numNodes > 0) {
        struct {
            CTRACKS cTrack[clipHeader.numNodes] <optimize=false>;
        } cTracks <name="Tracks">;
    }

    FSeek(clipHeader.propertiesOffs + start);
    if (clipHeader.numProperties > 0) {
        struct {
            struct PROPERTY Property[clipHeader.numProperties] <optimize=false>;
        } Properties;
    }


    
    if (HEADER.version == 99) 
        FSeek(clipHeader.keysOffs + start);
    else 
        FSeek(clipHeader.keysOffs + start);
    
    if (clipHeader.numKeys > 0)
        struct clipKey Keys[clipHeader.numKeys] <optimize=true>;

    if (clipHeader.namesOffsExtra[1] - clipHeader.namesOffs > 0) {
        FSeek(clipHeader.namesOffs+start);
        float Unknown_Floats[(clipHeader.namesOffsExtra[1] - clipHeader.namesOffs) / 4];
    }
    
    FSeek(clipHeader.namesOffsExtra[1] + start);
    struct {
        for (k = 0; k < clipHeader.numProperties + clipHeader.numNodes; k++) {
            struct StringRead Name(FTell(), 0, 1, 1, 0);
        }
    } Names;
    
    FSeek(clipHeader.unicodeNamesOffs + start);
    struct {
        for (k = 0; k < clipHeader.numProperties + clipHeader.numNodes; k++) {
            struct StringRead Name(FTell(), 0, 1, 0, 0);
            //struct {
            //    wstring Name;
            //} Name <open=true>;
        }
    } NamesUnicode <name="Names (Unicode)">;
    

    
    //while (ReadUInt64(FTell()) == 0) FSkip(8);
    
    
    
        
    if (HEADER.version != 60 && clipHeader.numNodes - 1 > 0) {
        FSeek(clipHeader.endClipStructsRelocation + start);
        struct {
            struct {
                int32 ukn;
                uint32 ukn1;
                uint64 ukn2;
            } endClipStruct[clipHeader.numNodes-1] <optimize=false, open=true>;
        } endClipStructs  <name="End Clip Structures">;
    }
    
    local int pos <hidden=true> = FTell();
    
    FSeek(clipHeader.propertiesOffs + start);
    if (clipHeader.numNodes && clipHeader.numProperties)
        struct {
            for (k=0; k<clipHeader.numNodes; k++) {
                if (cTracks.cTrack[k].propCount > 0) {
                    FSeek(clipHeader.propertiesOffs + start + (cTracks.cTrack[k].firstPropIdx * propSize));
                    struct PSTRUCT{
                        local int p <hidden=true>;
                        local string name<hidden=true>  = cTracks.cTrack[k].name;
                        for (p=0; p<cTracks.cTrack[k].propCount; p++)
                            PROPERTY Property <optimize=false>;
                    } cTrack <name=ReadPSTRUCT>;
                }
            }
        } Sorted_Data <name="Sorted Data (Edit Here)">;
    FSeek(pos);
    //FSeek(endClipStructsRelocation + start);
} CLIP_ENTRY <fgcolor=cGreen, read=ReadCLIP_ENTRY>;

wstring ReadCLIP_ENTRY(CLIP_ENTRY &c) {
    if (exists(c.cTracks.cTrack[1].name))
        return c.cTracks.cTrack[1].name;
    return "";
}

typedef struct MotlistClip {
    uint64 clipOffset[MOT_HEADER.clipCount] <optimize=false>;
	FSeek(clipOffset[0] + start);
    
    if (NOCLIP == FALSE) {
        local int q <hidden=true>;
        for (q=0; q<MOT_HEADER.clipCount; q++) {
            FSeek(clipOffset[q] + start);
            CLIP_ENTRY Clip;
        }
	} 
    
    if (exists(MOT_HEADER) && MOT_HEADER.Offs2 != 0 && ReadUInt64(MOT_HEADER.Offs2 + start + 8) > 0) {

        FSeek(MOT_HEADER.Offs2 + start);
        struct {
            uint64 ukn;
            uint64 dataSize;
            uint32 uknSCount, endHashCount;
            uint64 Blank;
            uint64 dataHdrSz1, dataHdrSz2;
            struct {
                if (uknSCount-1)
                    struct {
                        uint32 ukn, ukn;
                        uint32 Hash, Hash;
                        uint64 subStructsOffs; 
						uint64 mainSubStructOffs;
						
						if (MOT_HEADER.Offs2 + start + subStructsOffs < FileSize()) {
							FSeek(MOT_HEADER.Offs2 + start + subStructsOffs);
							struct {
								uint32 ukn[12];
                                if (HEADER.version != 60) {
								    FSeek(MOT_HEADER.Offs2 + start + ukn[4]);
								    ushort endFrame;
                                }
							} subStruct;
						} 

						
						if (MOT_HEADER.Offs2 + start + mainSubStructOffs < FileSize()) {
							FSeek(MOT_HEADER.Offs2 + start + mainSubStructOffs);
							struct {
								uint32 ukn[8];
								FSeek(MOT_HEADER.Offs2 + start + ukn[0]);
								uint ukn2[ukn[3]];
							} Sub_FrameData;
						} 
						FSeek(startof(mainSubStructOffs)+8);
                    } uknStruct[uknSCount-1] <optimize=false>;
                struct {
                    uint32 finalUkn, finalUkn, finalHash, finalHash;
                    uint64 finalUkn1; 
                    uint32 endHash, finalUkn2;
                } finalUknStruct;
            } uknStructs <name="Unknown Structures">;
            struct {
                uint32 endHash, ukn, hash2, ukn1;
                uint64 offset;
                pos2 = FTell();
                FSeek (MOT_HEADER.Offs2 + offset + start);
                uint32 ukn2;
                FSeek(pos2);
            } hashStruct[6] <optimize=false>;
            if (uknSCount > 1) {
                struct {
                    for (j = 0; j < uknSCount - 1; j++) {
                        struct {
                            if (uknStructs.uknStruct[j].mainSubStructOffs != 33845916581) {
                                FSeek(MOT_HEADER.Offs2 + start + uknStructs.uknStruct[j].subStructsOffs);
                                struct { 
                                    uint64 offs_Or_Value; 
                                    uint32 hash, ukn; 
                                } subStruct[3] <optimize=false, open=true>;
                                FSeek(MOT_HEADER.Offs2 + start + uknStructs.uknStruct[j].mainSubStructOffs);
                                struct { 
                                    uint64 fDataOffs; 
                                    uint32 hash, frameCount;   
                                } MainSubStruct <optimize=false, open=true>;
                                uint32 pad, ukn; uint64 padding;
                            }
                        } uknStruct2;
                    }
                } uknStructs2 <name="Unknown Structures 2">;
            }
        } dataHeader;
        
        if ((int)((MOT_HEADER.uknFloat[1] + 1) * 4) + dataHeader.hashStruct[0].offset + MOT_HEADER.Offs2 + start < FileSize()) {
            FSeek(dataHeader.hashStruct[0].offset + MOT_HEADER.Offs2 + start);
            struct {
                uint32 FrameData[MOT_HEADER.uknFloat[1] + 1]; 
                FSeek(dataHeader.hashStruct[1].offset + MOT_HEADER.Offs2 + start);
                if ((int)((MOT_HEADER.uknFloat[1] + 1) * 4) + FTell() < FileSize())
                    uint32 FrameIdx[MOT_HEADER.uknFloat[1] + 1];
                if (exists(dataHeader.uknStructs2.uknStruct2[0]))
                if ((MOT_HEADER.Offs2 + start + dataHeader.uknStructs2.uknStruct2[0].MainSubStruct.fDataOffs) != (dataHeader.hashStruct[2].offset + MOT_HEADER.Offs2 + start)) {
                    FSeek(dataHeader.hashStruct[2].offset + MOT_HEADER.Offs2 + start);
                    uint32 FrameUkn[6];
                    FSeek(dataHeader.hashStruct[4].offset + MOT_HEADER.Offs2 + start);
                    uint32 FrameUkn2[2];
                }
                if (dataHeader.uknSCount > 1) {
                    FSeek(MOT_HEADER.Offs2 + start + dataHeader.uknStructs2.uknStruct2[0].MainSubStruct.fDataOffs);
                    struct {
                        for (j = 0; j < dataHeader.uknSCount - 1; j++) {
                            FSeek(MOT_HEADER.Offs2 + start + dataHeader.uknStructs2.uknStruct2[j].MainSubStruct.fDataOffs);
                            struct {
                                struct {
                                    for (k = 0; k < dataHeader.uknStructs2.uknStruct2[j].MainSubStruct.frameCount; k++)
                                        struct {
                                            ubyte A, B, C, D;
                                        } frame;
                                } Frames <open=true>;
                                local int count = dataHeader.uknStructs2.uknStruct2[j].MainSubStruct.frameCount;
                            } FrameData ;
                        } 
                    } Sub_FrameData;
                    
                    if (HEADER.version != 60)
                        struct {
                            for (j = 0; j < dataHeader.uknSCount - 1; j++) {
                                FSeek(MOT_HEADER.Offs2 + start + dataHeader.uknStructs2.uknStruct2[j].subStruct[1].offs_Or_Value);
                                ushort Frame;
                            } 
                        } endFrameData;
                }
            } Frame_Data <name="Frame Data">;
        }
        FSeek(MOT_HEADER.Offs2 + start + dataHeader.dataSize);
        uint32 endHashes[dataHeader.endHashCount * 2] <name="End Hashes">;
    }
};
    string ReadPSTRUCT(PSTRUCT &input) { return input.name; }

typedef struct keys (uint32 keyCount, uint32 flags, uint64 frameDataOffs) {
    switch (flags >> 20)
    {
        case 2:
            ubyte frameIndex[keyCount];
            break;
        
        case 4:
            int16 frameIndex[keyCount];
            break;

        case 5:
            int32 frameIndex[keyCount];
            break;

        default:
            break;
    }
};

typedef struct FrameData (uint32 keyCount, uint32 flags, uint64 frameDataOffs) {
    local uint keyFrameDataType <format=hex> = flags & 0xF00000;
    local uint keyFrameDataTypeOther <format=hex> = flags >> 20;
    local uint compression <format=hex> = flags & 0xFF000;
 
    local uint unkFlag <format=hex> = flags & 0xFFF;
};

typedef ulong LocFrameType_t<name="Translation Decompression", read=ReadLocFrameType, write=WriteLocFrameType>;
    string ReadLocFrameType(LocFrameType_t f){
    if (MOT[0].MOT_HEADER.version == 65 || MOT[0].MOT_HEADER.version == 43) { 
        switch (f & 0xFF000)
        {   //RE2 and RE7
            case 0x00000: string s = "LoadVector3sFull"; break;
            case 0x20000: string s = "LoadVector3s5BitA"; break;
            case 0x30000: string s = "LoadVector3s10BitA"; break;
            case 0x40000: string s = "LoadVector3s10BitA"; break;
            case 0x70000: string s = "LoadVector3s21BitA"; break;
            case 0x31000: string s = "LoadVector3sXAxis"; break;
            case 0x32000: string s = "LoadVector3sYAxis"; break;
            case 0x33000: string s = "LoadVector3sZAxis"; break;
            case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
            case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
            case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
            default: string s = "Unknown Type"; break;
        }
    } else {
        switch (f & 0xFF000)
        {   //RE3
            case 0x00000: string s = "LoadVector3sFull"; break;
            case 0x20000: string s = "LoadVector3s5BitB"; break;
            case 0x30000: string s = "LoadVector3s5BitB"; break;
            case 0x40000: string s = "LoadVector3s10BitB"; break;
            case 0x80000: string s = "LoadVector3s21BitB"; break;
            case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
            case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
            case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
            case 0x24000: string s = "LoadVector3sXYZAxis16Bit"; break;
            case 0x41000: string s = "LoadVector3sXAxis"; break;
            case 0x42000: string s = "LoadVector3sYAxis"; break;
            case 0x43000: string s = "LoadVector3sZAxis"; break;
            case 0x44000: string s = "LoadVector3sXYZAxis"; break;
            default: string s = "Unknown Type"; break;
        }
    }
        return s;
    }

typedef float VectorFull <read=VectorRead, write=VectorWrite>;
    string VectorRead( VectorFull f ) {
        string s;
        SPrintf( s, "%f", f*100.0f );
        return s;
    }
    void VectorWrite( VectorFull &f, string s ) {
        local float ff = Atof(s);
        f = (VectorFull )( (float)(ff / 100.0f) );
    }

typedef ulong RotFrameType_t<name="Rotation Decompression", read=ReadRotFrameType, write=WriteRotFrameType>;
    string ReadRotFrameType(RotFrameType_t f){
    if (MOT[0].MOT_HEADER.version == 65 || MOT[0].MOT_HEADER.version == 43) { 
        switch (f & 0xFF000)
        {   //RE2 and RE7
            case 0x00000: string s = "LoadQuaternionsFull"; break;
            case 0xB0000: string s = "LoadQuaternions3Component"; break;
            case 0xC0000: string s = "LoadQuaternions3Component"; break;
            case 0x30000: string s = "LoadQuaternions10Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x50000: string s = "LoadQuaternions16Bit"; break;
            case 0x70000: string s = "LoadQuaternions21Bit"; break;
            case 0x21000: string s = "LoadQuaternionsXAxis16Bit"; break;
            case 0x22000: string s = "LoadQuaternionsYAxis16Bit"; break;
            case 0x23000: string s = "LoadQuaternionsZAxis16Bit"; break;
            case 0x31000: string s = "LoadQuaternionsXAxis"; break;
            case 0x41000: string s = "LoadQuaternionsXAxis"; break;
            case 0x32000: string s = "LoadQuaternionsYAxis"; break;
            case 0x42000: string s = "LoadQuaternionsYAxis"; break;
            case 0x33000: string s = "LoadQuaternionsZAxis"; break;
            case 0x43000: string s = "LoadQuaternionsZAxis"; break;
            default: string s = "Unknown Type"; break;
        }
    } else {                    
        switch (f & 0xFF000)
        {   //RE3
            case 0x00000: string s = "LoadQuaternionsFull"; break;
            case 0xB0000: string s = "LoadQuaternions3Component"; break;
            case 0xC0000: string s = "LoadQuaternions3Component"; break;
            case 0x20000: string s = "LoadQuaternions5Bit"; break;
            case 0x30000: string s = "LoadQuaternions8Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x50000: string s = "LoadQuaternions13Bit"; break;
            case 0x60000: string s = "LoadQuaternions16Bit"; break;
            case 0x70000: string s = "LoadQuaternions18Bit"; break;
            case 0x80000: string s = "LoadQuaternions21Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x21000: string s = "LoadQuaternionsXAxis16Bit"; break;
            case 0x22000: string s = "LoadQuaternionsYAxis16Bit"; break;
            case 0x23000: string s = "LoadQuaternionsZAxis16Bit"; break;
            case 0x31000: string s = "LoadQuaternionsXAxis"; break;
            case 0x41000: string s = "LoadQuaternionsXAxis"; break;
            case 0x32000: string s = "LoadQuaternionsYAxis"; break;
            case 0x42000: string s = "LoadQuaternionsYAxis"; break;
            case 0x33000: string s = "LoadQuaternionsZAxis"; break;
            case 0x43000: string s = "LoadQuaternionsZAxis"; break;
            default: string s = "Unknown Type"; break;
        }
    }
        return s;
    }

typedef ulong ScaleFrameType_t<name="Scale Decompression", read=ReadScaleFrameType, write=WriteScaleFrameType>;
    string ReadScaleFrameType(ScaleFrameType_t f){
    switch (f & 0xFF000)
    {
        case 0x00000: string s = "LoadVector3sFull"; break;
        case 0x20000: string s = "LoadVector3s5BitA"; break;
        case 0x30000: string s = "LoadVector3s10BitA"; break;
        case 0x34000: string s = "LoadScalesXYZ"; break; 
        case 0x40000: string s = "LoadVector3s10BitA"; break;
        case 0x70000: string s = "LoadVector3s21BitA"; break;
        case 0x31000: string s = "LoadVector3sXAxis"; break;
        case 0x32000: string s = "LoadVector3sYAxis"; break;
        case 0x33000: string s = "LoadVector3sZAxis"; break;
        case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
        case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
        case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
        default: string s = "Unknown Type"; break;
    }
        return s;
    }

typedef struct track {
    uint32 flags <format=binary>; //track compression among them
    uint32 keyCount;

    if (MOT_HEADER.version == 78 || MOT_HEADER.version == 458 || MOT_HEADER.version == 456) //40 bytes RE2, 20 bytes RE3
    { 
        uint32 frameIndOffs <format=hex>;
        uint32 frameDataOffs <format=hex>;
        uint32 unpackDataOffs <format=hex>;
    } else {
        uint32 frameRate;
        float  maxFrame;
        uint64 frameIndOffs <format=hex>;
        uint64 frameDataOffs <format=hex>;
        uint64 unpackDataOffs <format=hex>;    
    }

    local ubyte cmprssn <name="Track compression type"> = flags >> 20;
    local uint keyFrameDataType <format=hex> = flags & 0xF00000;
    local uint compression <format=hex> = flags & 0xFF000;
    local uint unkFlag <format=hex> = flags & 0xFFF;
    
};

typedef struct framedatatrns (uint32 keyCount, uint32 flags, uint64 frameDataOffs, uint64 unpackDataOffs, uint64 frameIndOffs) {
    if (frameIndOffs > 0) {
        FSeek(frameIndOffs);
        keys KEYS(keyCount, flags, frameDataOffs);
    }
    if (unpackDataOffs > start){
        FSeek(unpackDataOffs);
        float unpackData[8];
        pos2 = FTell();
    }
    FSeek(frameDataOffs);
    struct (uint32 keyCount, uint32 flags) {
        for (frame = 0; frame < keyCount; frame++){
            struct (uint32 flags) {
                if (exists(KEYS)) local int Time = KEYS.frameIndex[frame];
                switch (flags & 0xFF000)
                {
                    case 0x00000: //LoadVector3sFull
                        VectorFull TranslationX, TranslationZ, TranslationY;
                        break;
    
                    case 0x20000: 
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        if (MOT_HEADER.version == 65 || MOT_HEADER.version == 43) { //LoadVector3s5BitA RE2
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[6];
                        } else {                        //LoadVector3s5BitB RE3
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[3];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                        }
                        break;

                    case 0x34000:                       
                        if (MOT_HEADER.version == 65) { //LoadScalesXYZ RE2
                            float X;
                            local float Y = X;
                            local float Z = X;
                            break;
                        }

                    case 0x30000:                       //LoadVector3s10BitA RE2
                        if (MOT_HEADER.version == 78) { //LoadVector3s5BitB RE3
                            ushort TranslationData;  if (SKIP_UNPACK) break;
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[3];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                            break;
                        }
                    case 0x40000: 
                        uint32 TranslationData; if (SKIP_UNPACK) break;
                        if (MOT_HEADER.version == 65 || MOT_HEADER.version == 43) { //LoadVector3s10BitA RE2
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[4];
                            local float Y = unpackData[1] * (((TranslationData >> 10) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[5];
                            local float Z = unpackData[2] * (((TranslationData >> 20) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[6];
                        } else {                        //LoadVector3s10BitB RE3
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[3];
                            local float Y = unpackData[1] * (((TranslationData >> 10) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[4];
                            local float Z = unpackData[2] * (((TranslationData >> 20) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[5];
                        }
                        break;
    
                    case 0x70000:                       //LoadVector3s21BitA  RE2
                        uint64 TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (((TranslationData >> 00) & 0x1FFFFF) / 2097151.0f) + unpackData[4];
                        local float Y = unpackData[1] * (((TranslationData >> 21) & 0x1FFFFF) / 2097151.0f) + unpackData[5];
                        local float Z = unpackData[2] * (((TranslationData >> 42) & 0x1FFFFF) / 2097151.0f) + unpackData[6];
                        break;
    
                    case 0x80000:                       //LoadVector3s21BitB  RE3
                        uint64 TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (((TranslationData >> 00) & 0x1FFFFF) / 2097151.0f) + unpackData[3];
                        local float Y = unpackData[1] * (((TranslationData >> 21) & 0x1FFFFF) / 2097151.0f) + unpackData[4];
                        local float Z = unpackData[2] * (((TranslationData >> 42) & 0x1FFFFF) / 2097151.0f) + unpackData[5];
                        break;
    
                    case 0x31000:                       //LoadVector3sXAxis RE2
                    case 0x41000:                       // RE3
                        float X;
                        local float Y = unpackData[1];
                        local float Z = unpackData[2];
                        break;
    
                    case 0x32000:                       //LoadVector3sYAxis RE2
                    case 0x42000:                       // RE3
                        local float X = unpackData[0];
                        float Y;
                        local float Z = unpackData[2];
                        break;
    
                    case 0x33000:                       //LoadVector3sZAxis RE2
                    case 0x43000:                       // RE3
                        local float X = unpackData[0];
                        local float Y = unpackData[1];
                        float Z;
                        break;
    
                    case 0x21000:                       //LoadVector3sXAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (TranslationData / 65535.0f) + unpackData[1];
                        local float Y = unpackData[2];
                        local float Z = unpackData[3];
                        break;
    
                    case 0x22000:                       //LoadVector3sYAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[1];
                        local float Y = unpackData[0] * (TranslationData / 65535.0f) + unpackData[2];
                        local float Z = unpackData[3];
                        break;
    
                    case 0x23000:                       //LoadVector3sZAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[1];
                        local float Y = unpackData[2];
                        local float Z = unpackData[0] * (TranslationData / 65535.0f) + unpackData[3];
                        break;
    
                    case 0x24000:                       //LoadVector3sXYZAxis16Bit RE3
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X, Y, Z = unpackData[0] * (TranslationData / 65535.0f) + unpackData[3];
                        break;
                    
                    case 0x44000:                       //LoadVector3sXYZAxis RE3
                        float TranslationData;
                        local float X, Y, Z = TranslationData;
                        break;
    
                    default:
                        Printf("Unknown Translation Type: %x at FTell %d\n", (flags & 0xFF000), FTell());
                }
            } Frame (flags);
        }
    } Frames (keyCount, flags);
    if (unpackDataOffs > start) FSeek(pos2);
};

float wRot () {
    local float RotationW = 1.0f - (RotationX * RotationX + RotationY * RotationY + RotationZ * RotationZ);
    if (RotationW > 0.0f) RotationW = (float)Sqrt(RotationW);
    else RotationW = 0.0f;
    return RotationW;
}

typedef struct framedatarot (uint32 keyCount, uint32 flags, uint64 frameDataOffs, uint64 unpackDataOffs, uint64 frameIndOffs) {
    if (frameIndOffs > 0) {
        FSeek(frameIndOffs);
        keys KEYS(keyCount, flags, frameDataOffs);
    }
    if (unpackDataOffs > start) {
        FSeek(unpackDataOffs);
        float MaxUnpackX, MaxUnpackY, MaxUnpackZ, MaxUnpackW;
		if (FTell() + 16 > FileSize()) {
			local float MinUnpackX, MinUnpackY, MinUnpackZ, MinUnpackW;
		} else {
			float MinUnpackX; //todo: fix this
			float MinUnpackY;
			float MinUnpackZ;
			float MinUnpackW;
		}
        pos2 = FTell();
    }

    FSeek(frameDataOffs);
    struct (uint32 keyCount, uint32 flags) {
        for (frame = 0; frame < keyCount; frame++){
            //if (SKIP_UNPACK)
            //    break;
            struct (uint32 flags) {
                if (exists(KEYS)) local int Time = KEYS.frameIndex[frame];
                switch (flags & 0xFF000)
                {
                    case 0x00000:                       //LoadQuaternionsFull
                        float RotationX, RotationY, RotationZ, RotationW;
                        break;
    
                    case 0xB0000:                       //LoadQuaternions3Component
                    case 0xC0000: 
                        float RotationX;
                        float RotationY;
                        float RotationZ; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;
    
                    case 0x20000:                       //LoadQuaternions5Bit RE3
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1F) * (1.0f / 0x1F)) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 05) & 0x1F) * (1.0f / 0x1F)) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 10) & 0x1F) * (1.0f / 0x1F)) + MinUnpackZ;
                        local float RotationW = wRot();
                        break;
    
                    case 0x21000:                       //LoadQuaternionsXAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationY = 0.0f;
                        local float RotationZ = 0.0f;
                        local float RotationW = wRot();
                        break;
    
                    case 0x22000:                       //LoadQuaternionsYAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = 0.0f;
                        local float RotationY = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationZ = 0.0f;
                        local float RotationW = wRot();
                        break;
    
                    case 0x23000:                       //LoadQuaternionsZAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = 0.0f;
                        local float RotationY = 0.0f;
                        local float RotationZ = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationW = wRot();
                        break;
    
                    case 0x30000:                       //LoadQuaternions10Bit RE2
                        if (MOT_HEADER.version == 78) { //LoadQuaternions8Bit RE3 
                            ubyte RotationDataX, RotationDataY, RotationDataZ; if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * (RotationDataX * 0.000015259022f)) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * (RotationDataY * 0.000015259022f)) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * (RotationDataZ * 0.000015259022f)) + MinUnpackZ;
                            local float RotationW = wRot();
                            break;
                        }
                    case 0x40000:                       //LoadQuaternions10Bit RE3
                        uint32 RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x3FF) / 1023.0f) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 10) & 0x3FF) / 1023.0f) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 20) & 0x3FF) / 1023.0f) + MinUnpackZ;
                        local float RotationW = wRot();
                        break;
                        
                    case 0x31000:                       //LoadQuaternionsXAxis
                    case 0x41000:
                        float RotationX;
                        local float RotationY = 0.0f;
                        local float RotationZ = 0.0f; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;
    
                    case 0x32000:                       //LoadQuaternionsYAxis
                    case 0x42000:
                        local float RotationX = 0.0f;
                        float RotationY;
                        local float RotationZ = 0.0f; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;
    
                    case 0x33000:                       //LoadQuaternionsZAxis
                    case 0x43000:
                        local float RotationX = 0.0f;
                        local float RotationY = 0.0f;
                        float RotationZ; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;
    
                    case 0x50000:                       //LoadQuaternions16Bit RE2
                        if (MOT_HEADER.version == 78 || MOT_HEADER.version == 458 || MOT_HEADER.version == 456) { //LoadQuaternions13Bit RE3  
                            BitfieldDisablePadding(); BitfieldLeftToRight();  
                            uint64 RotationData : 40; FSkip(-3); if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1FFF) * 0.00012208521f) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * ((RotationData >> 13) & 0x1FFF) * 0.00012208521f) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * ((RotationData >> 26) & 0x1FFF) * 0.00012208521f) + MinUnpackZ;
                            local float RotationW = wRot();
                            BitfieldEnablePadding(); BitfieldRightToLeft(); 
                            break;
                        }
                    case 0x60000:                       //LoadQuaternions16Bit RE3
                        ushort RotationDataX, RotationDataY, RotationDataZ; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * (RotationDataX / 65535.0f) + MinUnpackX);
                        local float RotationY = (MaxUnpackY * (RotationDataY / 65535.0f) + MinUnpackY);
                        local float RotationZ = (MaxUnpackZ * (RotationDataZ / 65535.0f) + MinUnpackZ);
                        local float RotationW = wRot();
                        break;
    
                    case 0x70000:                       //LoadQuaternions21Bit RE2
                        if (MOT_HEADER.version == 78) { //LoadQuaternions18Bit RE3
                            uint64 RotationData : 56; FSkip(-1); if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1FFF) * 0.00012208521f) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * ((RotationData >> 13) & 0x1FFF) * 0.00012208521f) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * ((RotationData >> 26) & 0x1FFF) * 0.00012208521f) + MinUnpackZ;
                            local float RotationW = wRot();
                            break;
                        }
                    case 0x80000:                       //LoadQuaternions21Bit RE3
                        /*BitfieldDisablePadding(); BitfieldLeftToRight(); 
                        uint64 RotationX : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationY : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationZ : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationW : 21 <read=ReadQuaternions21Bit>;
                        BitfieldEnablePadding(); BitfieldRightToLeft(); */
                        uint64 RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1FFFFF) / 2097151.0f) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 21) & 0x1FFFFF) / 2097151.0f) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 42) & 0x1FFFFF) / 2097151.0f) + MinUnpackZ;
                        local float RotationW = wRot();
                        break;
                    default:
                        Printf("Unknown Rotation Type: %x at FTell %d\n", (flags & 0xFF000), FTell());
                }
            } Frame (flags);
        }
    } Frames (keyCount, flags);
    if (unpackDataOffs > start) FSeek(pos2);
};

/*string ReadQuaternions21Bit(uint64 &q) {
    local string s;
    SPrintf(s, "%g\n", (parentof(parentof(parentof(q))).MaxUnpack[] * (q / 2097151.0f)) + parentof(parentof(parentof(q))).MinUnpack[]);
    return s;
}*/

typedef struct {
    uint64 Address <format=hex>;
    if (ReadUInt(Address+4) == 1701999725) {
        local string motName = ReadWString(Address + ReadUInt64(Address + 48));
    } else if (ReadUInt(0) == 486) {
        local string motName = ReadWString(Address + ReadUInt64(Address + 88));
    } else
        local string motName = ReadWString(Address + 116);
    
    FSeek(startof(Address)+8);
    if (Address == 0) motName = "";
} POINTERS <read=ReadPOINTERS, write=WritePOINTERS, name=ReadPOINTERSNAME>;
    string ReadPOINTERSNAME (POINTERS &input) { return input.motName; }
    string ReadPOINTERS (POINTERS &input) { string s; SPrintf(s, "%u", input.Address); return s; }
    void WritePOINTERS (POINTERS &input, string s) { input.Address = Atoi(s); }

typedef struct motHdr {
    uint    version;
    char    ID[4]; 
    uint32  ukn00;
    uint32  motSize;
    uint64  offsToBoneHdrOffs <format=hex>;       //BoneBaseDataPointer
    uint64  boneClipHdrOffs <format=hex>; FSkip(8);   //BoneDataPointer
	if (version == 458 || version == 456) {
		FSkip(8);
        uint64  clipFileOffset <format=hex>;
        uint64  Offs1 <format=hex>;
        uint64  Offs2 <format=hex, name="Extra Data Offset">;
        FSkip(16);
        //NOCLIP = TRUE;
    } else {
        uint64  Offs1 <format=hex>;
        uint64  clipFileOffset <format=hex>;
        FSkip(16);
        uint64  Offs2 <format=hex, name="Extra Data Offset">;
    }
    
    uint64  namesOffs <format=hex>;
    float   frameCount;
    local int firstFrame = runningTotal;
    runningTotal += frameCount;
    float   blending <comment="Set to 0 to enable repeating">; 
    float   uknFloat;
    float   uknFloat;
    ushort  boneCount;
    ushort  boneClipCount;
    ubyte   clipCount;
    ubyte   uknPointer3Count;
    ushort  FrameRate;
    ushort  uknPointerCount;
    ushort  uknShort; 
	FSeek(namesOffs+start);
    wstring MOT_NAME <open=suppress>; 
    FSeek(startof(uknShort)+2);
};

typedef struct  {
    uint64 boneNameOffs <format=hex>;
    local int position <hidden=true> = FTell() ;
    FSeek(boneNameOffs + start);
    wstring boneName <open=suppress>;
    FSeek(position);
    uint64 parentOffs <format=hex>;
    uint64 childOffs <format=hex>;
    uint64 nextSiblingOffs <format=hex>;
    float  translation[4] <open=suppress>;
    float  quaternion[4] <open=suppress>;
    uint32 Index;
    uint   boneHash;    //MurMur3
    uint64 padding;
} bnHdr <read=ReadBNHDR>;
    string ReadBNHDR ( bnHdr &input ) { return input.boneName; }

typedef struct {
    wstring String <open=suppress>;
} BONENAME <read=ReadBONENAME>;
    string ReadBONENAME (BONENAME &input) { return input.String; }

typedef struct {
    if (MOT_HEADER.version == 65)
    {
        ushort    boneIndex;
        trckFlg_t trackFlags; // flags for type: translations ?+    rotations xor scales
        uint32      boneHash <format=hex>;  // MurMur3
        float     uknFloat;  // always 1.0?
        uint32     padding;
        uint64 trackHdrOffs <format=hex>; //keysPointer
    }
    else
    {
        ushort    boneIndex;
        trckFlg_t trackFlags;
        uint      boneHash <format=hex>;
        if  (MOT_HEADER.version == 43)
            uint64 trackHdrOffs <format=hex>; //keysPointer
        else 
            uint32 trackHdrOffs <format=hex>;
    }

    local string name <hidden=true> = "";
    if (exists(BONE_HEADERS.BONE_HEADER[boneIndex].boneName))
        name = BONE_HEADERS.BONE_HEADER[boneIndex].boneName; 
    else if (exists(MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIndex].boneName))
        name = MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIndex].boneName;
} BONECLIPHEADER <read=ReadBONECLIPHEADER>;
    string ReadBONECLIPHEADER (BONECLIPHEADER &input) { return input.name; }

typedef struct {
    local uint64 TranslationFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION)
        track trnsltn <name="Translation">;

    local uint64 RotationFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION)
        track rotation <name="Rotation">;

    local uint64 ScaleFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE)
        track scale <name="Scale">;

    pos3 = FTell();

    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION && trnsltn.flags >= 0){ FSeek(TranslationFlagOff); LocFrameType_t TranslationType;}
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION && rotation.flags >= 0){ FSeek(RotationFlagOff); RotFrameType_t RotationType;}
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE && scale.flags >= 0){ FSeek(ScaleFlagOff); ScaleFrameType_t ScaleType;}

    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION){
        if (trnsltn.frameIndOffs > 0) FSeek(trnsltn.frameIndOffs+start);
        else FSeek(trnsltn.frameDataOffs+start);
        framedatatrns Frames(trnsltn.keyCount, trnsltn.flags, trnsltn.frameDataOffs+start, trnsltn.unpackDataOffs+start, trnsltn.frameIndOffs+start)<name="Frame Data: Translation">;
    }
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION){
        if (rotation.frameIndOffs > 0) FSeek(rotation.frameIndOffs+start);
        else FSeek(rotation.frameDataOffs+start);
        framedatarot Frames(rotation.keyCount, rotation.flags, rotation.frameDataOffs+start, rotation.unpackDataOffs+start, rotation.frameIndOffs+start)<name="Frame Data: Rotation">;
    }
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE){
        if (scale.frameIndOffs > 0) FSeek(scale.frameIndOffs+start);
        else FSeek(scale.frameDataOffs+start);
        framedatatrns Frames(scale.keyCount, scale.flags, scale.frameDataOffs+start, scale.unpackDataOffs+start, scale.frameIndOffs+start)<name="Frame Data: Scale">;
    }
    FSeek(pos3);
    local int boneIdx<name="Bone index"> = BONE_CLIP_HEADERS.bnClipHdr[j].boneIndex;
    local string name <hidden=true> = "";
    
    if (exists(BONE_HEADERS.BONE_HEADER[boneIdx].boneName))
        name = BONE_HEADERS.BONE_HEADER[boneIdx].boneName; 
    else if (exists(MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIdx].boneName))
        name = MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIdx].boneName;

} TRACKS <name="TRACKS", read=ReadTRACKS>;
    string ReadTRACKS (TRACKS &input) { return input.name; }

typedef struct 
{
    StringRead className(-1, start, 0, 1, 0);
    StringRead name(-1, start, 0, 0, 0);
    StringRead tagTbl(-1, start, 0, 0, 0);
    uint64 tagHashTbl;
    uint64 parameterTbl;
    unsigned int id;
    unsigned int classNameHash;
    unsigned int nameHash;
    char tagCount;
    char paramCount;
    enum <char>
    {
        NodeType_Unknown = 0x0,
        NodeType_GameObject = 0x1,
        NodeType_Component = 0x2,
        NodeType_Folder = 0x3,
    } nodeType;
    
    char flags;
    
    FSeek(start+parameterTbl);
    struct PARAM {
        struct StringRead Name(-1, start, 0, 1, 1);
        uint A;
        enum {
            ParamType_Bool = 0x0,
            ParamType_U8 = 0x1,
            ParamType_S8 = 0x2,
            ParamType_U16 = 0x3,
            ParamType_S16 = 0x4,
            ParamType_S32 = 0x5,
            ParamType_U32 = 0x6,
            ParamType_S64 = 0x7,
            ParamType_U64 = 0x8,
            ParamType_F32 = 0x9,
            ParamType_F64 = 0xA,
            ParamType_Str8 = 0xB,
            ParamType_Str16 = 0xC,
            ParamType_ExtraData = 0xD,
            ParamType_Hermite = 0xE,
            ParamType_Guid = 0xF,
            ParamType_Vec2 = 0x10,
            ParamType_Vec3 = 0x11,
            ParamType_Vec4 = 0x12,
            ParamType_Matrix = 0x13,
        } paramType;
        uint Hash;
        switch (paramType) {
            case ParamType_Str8:
                struct StringRead String(-1, start, 0, 1, 0);
                break;
            case ParamType_Str16:
                struct StringRead String(-1, start, 0, 0, 0);
                break;
            case ParamType_Bool:
            case ParamType_U8:
                ubyte value;
                break;
            case ParamType_S8:
                byte value;
                break;
            case ParamType_U16:
                ushort value;
                break;
            case ParamType_S16:
                short value;
                break;
            case ParamType_S32:
                int value;
                break;
            case ParamType_U32:
                uint value;
                break;
            case ParamType_S64:
                int64 value;
                break;
            case ParamType_U64:
                uint64 value;
                break;
            case ParamType_F32:
                float value;
                break;
            case ParamType_F64:
                double value;
                break;
            default:
                int64 paramOffset;
                break;
        }
        
        if (exists(paramOffset)) {
            FSeek(start + paramOffset);
            switch (paramType) {
                case ParamType_Guid:
                    rGUID Guid;
                    break;
                case ParamType_Vec2:
                    float vec2[2];
                    break;
                case ParamType_Vec3:
                    float vec3[3];
                    break;
                case ParamType_Vec4:
                    float vec4[4];
                    break;
                case ParamType_Matrix:
                    float matrix[16];
                    break;
                case ParamType_ExtraData:
                case ParamType_Hermite:
                default:
                    int64 value;
                    break;
            }
            
        }

        FSeek(startof(Hash)+12);

    } Param[paramCount] <read=ReadPARAM, name=ReadPARAMName, optimize=false>;
    
    
    FSeek(startof(flags)+1);
} NodeData <read=ReadNodeData>;

    string ReadNodeData (NodeData &n) {
        if (exists(n.className.String))
            return n.className.String;
        return "";
    }

    string ReadPARAM (PARAM &p) {
        string s;
        if (exists(p.String))
            return p.String.String;
        if (exists(p.value))
            if (p.Name.String == "MotionID")
                return ReadMotNodeId(p.value);
            SPrintf(s, "%g", p.value);
        return s;
    }
    
    string ReadPARAMName (PARAM &p) { return EnumToString(p.paramType) + " " +  p.Name.String; }


typedef struct 
{
    unsigned int inputNodeIndex;
    unsigned int inputPinNo;
    unsigned int outputNodeIndex;
    unsigned int outputPinNo;
    enum
    {
        LinkType_Unknown = 0x0,
        LinkType_Motion = 0x1,
        LinkType_Param = 0x2,
    } linkType;
    unsigned int reserved <hidden=true>;
    uint64 inputPinGuidOffs;
    uint64 outputPinGuidOffs;
    FSeek(start + inputPinGuidOffs);
    if (inputPinGuidOffs)
        rGUID inputPinGuid;
    FSeek(start + outputPinGuidOffs);
    if (outputPinGuidOffs)
        rGUID outputPinGuid;
    if (exists(Nodes.mNodeData[inputNodeIndex])) {
        FSeek(startof(Nodes.mNodeData[inputNodeIndex]));
        struct NodeData inputNode;// <size=56>;
    }
    if (exists(Nodes.mNodeData[outputNodeIndex])) {
        FSeek(startof(Nodes.mNodeData[outputNodeIndex]));
        struct NodeData outputNode;// <size=56>;
    }
    FSeek(startof(outputPinGuidOffs) + 8);
} LinkData;


//mtre
typedef struct {
    start = FTell();
    uint    version;
    char    ID[4]; 
    FSkip(8);    
    
    StringRead userVariablesPath(-1, start, 0, 0, 0);
    StringRead resourcePathTbl(-1, start, 0, 0, 0);

    uint64 mNodeDataTbl;
    uint64 mLinkDataTbl;
    
    StringRead nameStr(-1, start, 0, 0, 0); ;
    
    ushort motNodeIdTbl;
    ushort mNodeCount;
    ushort mLinkCount;
    ushort rootNodeIndex;
    ushort resourceCount;
    ushort motNodeCount;
    ushort ukn;
    ushort ukn;
    ushort ukn;
    
    FSeek(start + motNodeIdTbl);
    ushort motNodeId[resourceCount] <read=ReadMotNodeIdShort>;

    FSeek(start + mNodeDataTbl);
    struct {
        struct NodeData mNodeData[resourceCount] <optimize=false>;
    } Nodes;

    FSeek(start + mLinkDataTbl);
    struct {
        struct LinkData mLinkData[motNodeCount] <optimize=false>;
    } Links;

} mtre <read=readmtre>;



string readmtre(mtre &m) { return m.nameStr.String; }

string ReadMotNodeId(int m) {
    if (exists(MOT_INDICES)) {
        local int i;
        for (i = 0; i < HEADER.numOffs; i++) {
             if (MOT_INDICES.MOT_INDEX[i].motNumber == m)
                return ReadMotIndex(MOT_INDICES.MOT_INDEX[i]);
        }
    }
    return "";
}

string ReadMotNodeIdShort(ushort m) {
    return ReadMotNodeId((int)m);
}

//main mot struct
typedef struct {
    start = FTell();
    motHdr MOT_HEADER <open=false>;
    if (!exists(HEADER)) {
        struct { ubyte blank; local int version = 99; } HEADER <hidden=true>; //false header
        FSkip(-1);
        if (MOT_HEADER.version == 43) HEADER.version = 60;
        else if (MOT_HEADER.version == 65) HEADER.version = 85;
        else if (MOT_HEADER.version == 78) HEADER.version = 99;
        else if (MOT_HEADER.version == 458 || MOT_HEADER.version == 456) HEADER.version = 486;
    }
    if (!SKIPALL) {
        if ( MOT_HEADER.motSize == 0 || MOT_HEADER.motSize > MOT_HEADER.offsToBoneHdrOffs ) { 
            FSeek(MOT_HEADER.offsToBoneHdrOffs+start);
            struct {
                uint64  boneHdrOffs <format=hex>;
                uint64  boneHdrCount;
                if (boneHdrCount <= 1000) {
                    bnHdr BONE_HEADER[boneHdrCount] <optimize=false>;
                    BONENAME BONE_NAME[BONE_HEADERS.boneHdrCount] <optimize=false, hidden=true>;
                }
            } BONE_HEADERS;
        }
        if (MOT_HEADER.boneClipCount) {
            FSeek(MOT_HEADER.boneClipHdrOffs+start);
            
                struct {
                    BONECLIPHEADER bnClipHdr[MOT_HEADER.boneClipCount] <optimize=false>; //, name="BONE CLIP HEADER"
                } BONE_CLIP_HEADERS; // <name="BONE CLIP HEADER">
        
            skipToNextLine();
            struct {
                for (j = 0; j < MOT_HEADER.boneClipCount; j++)
                {
                    FSeek(BONE_CLIP_HEADERS.bnClipHdr[j].trackHdrOffs+start);
                    TRACKS tracks;
                }
            } clipTracks <name="CLIP TRACKS">;
        } else Printf("Empty mot at %u\n", FTell());
        if ( MOT_HEADER.Offs1 > 0) {
            FSeek(MOT_HEADER.Offs1 + start);
            wstring JMAP;
        }
    }
    
    if ( NOCLIP == FALSE && MOT_HEADER.clipFileOffset > 0 && MOT_HEADER.clipCount ) { //&& MOT_HEADER.version != 43
        FSeek(MOT_HEADER.clipFileOffset + start);
        MotlistClip CLIP;
    }

    //find end of mot
    if (bIsMotFile) 
        FSeek( FileSize() );
    else if (i == numOffs-1 && HEADER.Pointers[i].Address < HEADER.colOffs)
        FSeek(HEADER.colOffs);
    else findEndOfMot();

} mot <read=ReadMOT>;//, size=SizeMOT>; 
    
    string ReadMOT ( mot &input ) { 
        local string s;
        if (input.MOT_HEADER.version <= 78)
            SPrintf(s," (%g frames)", ReadFloat(startof(input)+88));
        else SPrintf(s," (%g frames)", ReadFloat(startof(input)+96));
		if (ReadUInt(startof(input)) == 458 || ReadUInt(startof(input)) == 456) {
			return ReadWString(startof(input) + ReadUInt64(startof(input) + 88)) + s; 
		} else return ReadWString(startof(input) + 116) + s; 
	} 
    
	uint SizeMOT ( mot &input ) { 
		local uint posStart = FTell();
		local uint finalPosition = startof(input) + 16;
		if (ReadUInt64(startof(input) + 72))
			finalPosition = ReadUInt64(startof(input) + 72) + startof(input);
		FSeek(finalPosition);
    	while (ReadUInt(FTell()+4) != 544501613) {	
			if (FTell()+18 < FileSize()) {		
				if ((exists(HEADER) && FTell() >= HEADER.colOffs) && startof(input) < HEADER.colOffs) {
					FSeek(HEADER.colOffs);
					break;
				}
				if (FTell()+16 >= FileSize()) {
					FSeek(FileSize());
            		break; 
				}
				FSkip(16);
			} else { FSeek(FileSize()); break;};
    	}
		finalPosition = FTell();
		FSeek(posStart);
		return finalPosition - startof(input);
		//return getMotSize(startof(input)); 
	}

typedef struct  {
    if (HEADER.version != 60) 
        FSkip(8);
    ushort motNumber; 
    ushort Switch <hidden=false>;
    if (ReadUInt(FTell()) != 0) uint32 hash; else FSkip(4);
    if (HEADER.version != 60) FSkip(8); else FSkip(4);
    local uint32 index <hidden=true> = i ;
} motIndex <read=ReadMotIndex>; //name=ReadMotIndexName
    
    string ReadMotIndex ( motIndex &input ) { 
        string s; 
        SPrintf(s, "%u -- %s", ReadUShort(startof(input)+8), HEADER.Pointers[input.index].motName);
        return s; 
    }


/* ---FUNCTIONS---- */
int isInArr(int64 val, int64 arr[]){
    local int a;

    for(a = 0; a < sizeof(arr)/8; a++)
    {
        if(arr[a] == val)
            return true;
    }
    return false;
}

/* ----START---- */
ReadBytes(bytes, 4, 4);
if (bytes == "mot ")
{
    bIsMotFile = 1;
    mot MOT;
}
else if (NOCLIP == FALSE && ReadUInt(FTell()) == 1346980931)
{
    struct { local int version = 99; } HEADER <hidden=true>; 
    CLIP_ENTRY Clip;
}
else 
{
    struct {
        uint32  Version;
        local uint version <hidden=true> = Version;
        char    ID[4];
        uint64  padding;
        uint64  pointersOffs <format=hex>; // AssetsPointer in Tyrant
        uint64  colOffs <format=hex>; // UnkPointer
        uint64  motListNameOffs <format=hex>; //NamePointer
        if (version != 60) {
            uint64  padding; //UnkPointer01
        }
        uint32  numOffs; FSeek(motListNameOffs); //AssetCount
        wstring motListName <open=suppress>; FSeek(pointersOffs);
        POINTERS Pointers[numOffs] <optimize=false>;
        if (version == 484)
            version = 486;
    } HEADER;

    local int64 tmpArr[HEADER.numOffs] <format=hex, hidden=true>, \
                isUnique[HEADER.numOffs] <format=hex, hidden=true>;

    //count offsets without nulls and duplicates 
    for (i = 0; i < HEADER.numOffs; i++)
    {
        if (HEADER.Pointers[i].Address && !isInArr(HEADER.Pointers[i].Address, tmpArr))
        {
            numOffs++;
            isUnique[i] = 1;
        }
        tmpArr[i] = HEADER.Pointers[i].Address;
    }

    //fill the array with unique non-zero offsets
    local int64 offs[numOffs] <format=hex, hidden=true>;
    for (i = 0; i < HEADER.numOffs; i++)
    {
        if (HEADER.Pointers[i].Address && isUnique[i])
        {
            offs[j] = HEADER.Pointers[i].Address;
            j++;
        }
    }

    motCounter = 0;
    for (i = 0; i < numOffs; i++)
    {
        FSeek(offs[i]);
        if (ReadByte() == 43 || ReadByte() == 65 || ReadByte() == 78 || ReadUInt(FTell()) == 458 || ReadUInt(FTell()) == 456) {
            mot MOT;
            FSeek( i < numOffs-1 ? offs[i+1] : FileSize());
            motCounter++;
        }    
        else if (ReadByte() == 4 || ReadByte() == 5 || ReadByte() == 10)
        {
            //struct {
            //    FSeek( i < numOffs-1 ? offs[i+1] : (HEADER.colOffs > 0 ? HEADER.colOffs : FileSize) );
            //} MOT_TREE;
            SetForeColor(cGreen);
            mtre MTRE;
            SetForeColor(cNone);
        }
        else if (ReadByte() == 7)
        {
            struct {
                FSeek( i < numOffs-1 ? offs[i+1] : (HEADER.colOffs > 0 ? HEADER.colOffs : FileSize) );
            } MCAM;
        }
    }

    FSeek(HEADER.colOffs);
    struct {
        for (i = 0; i < HEADER.numOffs; i++){
            motIndex MOT_INDEX;
        }
    } MOT_INDICES;
    //Printf("Checking %u %u\n", FTell(), ReadUInt64(FTell()));
    if (FTell() < FileSize() - 8 && (ReadUInt64(FTell()) == FTell() + 8 || ReadUInt64(FTell()) == FTell() + 16)) {
        start = 0;
        isEndOfClip = TRUE; 
        struct {
            while (findNextOfInt(1346980931) != FileSize() && findNextOfInt(1346980931) < FTell() + 190 )
                CLIP_ENTRY Clip;
        } END_CLIP;
    }
}
Printf("Number of valid entries: %d\n", numOffs);